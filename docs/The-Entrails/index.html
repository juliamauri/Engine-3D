<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

  <link rel="stylesheet" href="../style.css" />

  <link rel="stylesheet" href="../scss/custom_accordion.css" />


  <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png" />
  <link rel="manifest" href="../site.webmanifest" />

  <meta name="keywords"
    content="C++, Game Engine, RedEye Game Development, Graphics Programming, Video Game Engines, Game Programming, Unity Like, Shader, OpenGL, SDL, RedEye Engine" />

  <meta property="og:title" content="RedEye Engine, a Video Game Development C++ Engine" />
  <meta property="og:type" content="website" />
  <meta property="og:description"
    content="What’s special about RedEye Engine? The code was written from scratch using a total of 15 C++ libraries. We started by building a geometry loader that could render the scene with simple controls for the camera. Once the base was solid we moved on to optimize the rendering process (frustum culling and quadtrees) and resource management. For the finishing touches we: Added shader pipeline with integrated editor so that shaders can be modified, compiled and updated instantly. Changed quadtree for a better space partitioning algorithm: Dynamic Bound Box Tree; the same Overwatch uses. Added Unity-like resource management with binary save/load for all the engines resources." />
  <meta property="og:image"
    content="https://raw.githubusercontent.com/juliamauri/RedEye-Engine/master/docs/thumbnail.png" />
  <meta property="og:site_name" content="RedEye Engine" />

  <meta name="Twitter:card" content="summary with large image" />
  <meta name="Twitter:url" content="https://www.redeye-engine.es/" />
  <meta name="Twitter:title" content="RedEye Engine, a Video Game Development C++ Engine" />
  <meta name="Twitter:description"
    content="What’s special about RedEye Engine? The code was written from scratch using a total of 15 C++ libraries." />
  <meta name="Twitter:image"
    content="https://raw.githubusercontent.com/juliamauri/RedEye-Engine/master/docs/thumbnail.png" />

  <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "SoftwareSourceCode",
            "name": "RedEye Engine",
            "alternateName": "Red Eye Engine",
            "url": "https://www.redeye-engine.es/",
            "codeRepository": "https://github.com/juliamauri/RedEye-Engine",
            "description": "Engine 3D(OpenGL)",
            "codeSampleType": "full (compile ready) solution",
            "programmingLanguage": "c++",
            "runtimePlatform": "Microsoft Visual C++",
            "targetProduct": {
                "name": "RedEye Engine",
                "operatingSystem": "Windows",
                "applicationCategory": "Video Game Engines"
            },
            "about": "What’s special about RedEye Engine? The code was written from scratch using a total of 15 C++ libraries. We started by building a geometry loader that could render the scene with simple controls for the camera. Once the base was solid we moved on to optimize the rendering process (frustum culling and quadtrees) and resource management. For the finishing touches we: Added shader pipeline with integrated editor so that shaders can be modified, compiled and updated instantly. Changed quadtree for a better space partitioning algorithm: Dynamic Bound Box Tree; the same Overwatch uses. Added Unity-like resource management with binary save/load for all the engines resources.",
            "abstract": "Red Eye is a 3D Game Engine written in C++ as an assignment for a university course.",
            "accessModeSufficient": ["textual", "visual"],
            "acquireLicensePage": "https://github.com/juliamauri/RedEye-Engine/blob/master/LICENSE",
            "video": "https://www.youtube.com/watch?v=kDCOSGXkqL4",
            "image": "https://raw.githubusercontent.com/juliamauri/RedEye-Engine/master/docs/thumbnail.png",
            "author": [{
                "@type": "Person",
                "familyName": "Mauri Costa",
                "givenName": "Julià",
                "name": "Julià Mauri Costa"
            }, {
                "@type": "Person",
                "familyName": "Sardón",
                "givenName": "Ruben",
                "name": "Ruben Sardón"
            }]
        }
    </script>


  <title>RedEye Engine - The Entrails</title>
</head>

<body style="background-color: #0D0D0D;">

  <nav class="navbar navbar-expand-lg navbar-dark sticky-top" style="background-color: #203F59;">
    <div class="container-fluid">
      <a class="navbar-brand" href="https://www.redeye-engine.es/" style="color: #4ECBD9">
        <img src="../favicon-32x32.png" width="30" height="30" class="d-inline-block align-top" alt="">
        RedEye Engine</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup"
        aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="https://www.redeye-engine.es/" style="color: #4ECBD9">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://www.redeye-engine.es/The-Brains/" style="color: #4ECBD9">The
              Brains</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://www.redeye-engine.es/The-Entrails/" style="color: #4ECBD9">The
              Entrails</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://www.redeye-engine.es/Whats-Next/" style="color: #4ECBD9">What's Next?</a>
          </li>
        </ul>
        <form class="d-flex">
          <div class="pe-2">
            <a href="https://github.com/juliamauri/RedEye-Engine/releases/download/v5.0/RedEye.Engine.v5.0.zip"
              class="btn btn-primary btn-sm" role="button">Download</a>
          </div>
          <a href="https://github.com/juliamauri/RedEye-Engine" class="btn btn-secondary btn-sm" role="button">Source
            Code</a>
        </form>
      </div>
    </div>
  </nav>

  <div class="jumbotron jumbotron-fluid m-5">
    <div class="container-left ml-3">
      <h1 class="display-4 mb-5" style="font-weight: 600;">The Entrails</h1>
      <p class="lead" style="color: #ffffff">The engine’s earliest state was a simple application class back in early
        2018 that held basic modules for starting and closing a blank window. After developing features continuously, we
        now even have our own particle pipeline system implemented. For further documentation on how the engine was
        built and works, feel free to check the repository’s <a
          href="https://github.com/juliamauri/RedEye-Engine/wiki/Release-Version-Notes">wiki</a>
        section.</p>
    </div>
  </div>

  <div class="accordion m-5 text-white" id="entrails_content">
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingOne">
        <button class="accordion-button text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#EngineSkeleton" aria-expanded="true" aria-controls="EngineSkeleton">
          <h4>Engine Skeleton</h4>
        </button>
      </h2>
      <div id="EngineSkeleton" class="accordion-collapse collapse show" aria-labelledby="headingOne"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>
            The application class is the engine’s skeleton. It holds all modules and it is the only class used in our
            C++’s main function call. Constructor and Initialization calls setup all systems and check for any errors
            during these procedures. Mainloop updates the modules each frame and controls timing to use extra
            milliseconds
            on secondary procedures. Application contains these modules:
          </p>
          <p>&#9642; <strong>Input</strong>: Uses SDL Input subsystem to record I/O events from mouse and keyboard and
            also window’s events. The module counts with another queue reserved for Redeye’s systems’ internal events
            such as gameobjects changing transform or an editor window changing size. </p>
          <p>&#9642; <strong>Window</strong>: Uses SDL Window subsystem to request a single window. We intend to expand
            its use to several windows at a later stage to allow for easier editor tabs organization.</p>
          <p>&#9642; <strong>Scene</strong>: Holds the ECS (Entity-Component System) and complementary systems to manage
            it more efficiently. The <a href="https://www.redeye-engine.es/The-Entrails/#SceneOptimization">Scene
              Optimization</a> section digs deeper into how they operate.</p>
          <p>&#9642; <strong>Physics</strong>: Latest module addition for building the new pipeline. It was envisioned
            to hold other physical entities apart from particles. The other planned features can be found listed at the
            <a href="https://www.redeye-engine.es/Whats-Next/">What's Next?</a> page.
          </p>
          <p>&#9642; <strong>Editor</strong>: Powered by ImGUI, the editor module handles the user interface and lets us
            navigate, use and customize all the engine’s systems. It holds all the available menus and allows resizing,
            repositioning and docking them for a custom setup. Modules and some other classes have a DrawEditor function
            to portray data structures to the user interface. Check the <a
              href="https://www.redeye-engine.es/The-Entrails/#UserInterface">User Interface</a> section for an overview
            of the different editor windows.</p>
          <p>&#9642; <strong>Renderer</strong>: Uses OpenGL to communicate with the GPU and draw scenes. It has numerous
            ways to customize how the scenes are displayed for each different viewport used: game, editor and particles.
            Toggle debug drawing options, light modes and other rendering flags. For a more detailed overview on how the
            different elements are drawn, check the <a
              href="https://www.redeye-engine.es/The-Entrails/#ShaderPipeline">Shader Pipeline</a> section.</p>
          <p>&#9642; <strong>Audio</strong>: Using Wwise, the engine can load and playback audio files. This powerful
            library is implemented scarcely as we wish to expand its use when setting up the scripting system and allow
            users to fully apply the audio engine’s features.</p>
          <p>
            The previous modules are systems that require being updated each frame. Time controls and module settings
            are customizable through the Configuration panel. This panel should end up becoming an individual window,
            but because we have to test all the different configurations, we left it visible at the right-bottom corner.
            Project configuration is stored in a config.json file that saves your presets for later use.
          </p>
          <p>
            Update-less systems contained within App include code for hardware detection, the console and file system.
            The console counts with options to filter logs based on their type or file source. Scene and resource
            loading are described in the <a
              href="https://www.redeye-engine.es/The-Entrails/#ResourceManagement">Resource Managemen</a> section.
          </p>
        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingTwo">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#Particles" aria-expanded="false" aria-controls="Particles">
          <h4>Particles</h4>
        </button>
      </h2>
      <div id="Particles" class="accordion-collapse collapse" aria-labelledby="headingTwo"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>
            Particle pipeline is the latest feature in v5.0. Through the physics module, particle simulations run and
            can be customized in numerous ways at the workspace window. It even counts with its own camera to display
            simulations without having to hit play on the scene. The editable fields can be split into emission, physics
            and rendering attributes.
          </p>
          <h4>Emission</h4>
          <p>&#9642; <strong>Max Particles</strong>: caps particle spawning to a given limit.</p>
          <p>&#9642; <strong>Intervals</strong>: emission can be set to enable spawning at intermittent intervals or
            operate at different on and off intervals.</p>
          <p>&#9642; <strong>Spawning Method</strong>: the default emitter is set to spawn a constant stream of
            particles and now can be changed to bursts. It requires defining the number of particles per burst and the
            time between bursts. Particularly useful for explosion effects where particles start flying in different
            directions at the same time.</p>
          <p>&#9642; <strong>Timing</strong>: digging into the engine’s complementary systems, particles now react to
            the scene’s playback controls and have the option to start on par with the scene.</p>
          <p>&#9642; <strong>Time multiplier</strong>: scales the speed of simulation playback</p>
          <p>&#9642; <strong>Spawn frequency</strong>: defines number of new particles per second</p>
          <p>&#9642; <strong>Lifetime</strong>: defines the amount of time particles will live. It can be set to a
            random value between a given interval.</p>
          <p>&#9642; <strong>Speed</strong>: sets the initial speed a particle will hold when spawned. It can be set to
            a random value between a given interval.</p>
          <p>&#9642; <strong>Emitter Shape</strong>: defines the area over which new particles will appear. This gets
            complicated to handle; because, if many particles are spawned with physics within a reduced amount of space,
            they will overlap, and some spawned particles will have an unnatural instantaneous resolution. So be warned
            of its mishaps when limiting particle space. Bounding the space to an even smaller margin for particles will
            saturate processing time with constant collisions. To face this issue, we set up 6 different types of
            emitter shapes: Point, Circle, Ring, Sphere, Hollow sphere and AABB.</p>
          <p>&#9642; <strong>Parent Dependencies</strong>: parent position and speed are shown in the status tab and
            used when changing the emission from local to global space instantiation or if particles inherit the
            gameobjects speed. Because of the dynamically handled hash mapped ECS, we cannot store the gameobjects
            pointer for easy access and so the component handles the bridge between by sending the data to the emitter.
          </p>

          <h4>Physics</h4>
          <p>&#9642; <strong>External Forces</strong>: adds constant force acceleration to each particle to simulate
            gravity and/or wind.</p>
          <p>&#9642; <strong>Boundary</strong>: boundaries have 3 different shapes available and editable through the
            ImGui editor fields. The need to resolve collisions can now be removed if we kill the particles when
            reaching the boundaries.</p>
          <p>&#9642; <strong>Collider</strong>: Boundaries have no effect on collier-less particles. To check
            collisions, they must contain mass and restitution properties; and a radius, given they are set to spheres.
          </p>

          <h4>Rendering</h4>
          <p>&#9642; <strong>Orientation</strong>: for simple sprites, 3d effect is achieved by billboarding: aligning
            the sprite with the camera used. Choose between orientation configurations or set your own value.</p>
          <p>&#9642; <strong>Geometry</strong>: choose between using imported meshes or primitive shapes to display
            using the simulations. We improved the particle system for optimized VAO management as we integrated them
            into the resource system.</p>
          <p>&#9642; <strong>Color & Opacity</strong>: Change the color component of the geometry and modify its
            transparency. You can base these values on the simulation’s state such as over particle lifetime, distance
            or speed. Furthermore, the pipeline counts with curve input support.</p>
          <p>&#9642; <strong>Lights</strong>: particles can be set to emit all the same light, or have independent light
            components. These properties include color, intensity and specular values. With the improved graphics memory
            allocation we increased maximum supported lights from 64 to 203. Further light configuration is available
            through the render module.</p>

        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingThree">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#ShaderPipeline" aria-expanded="false" aria-controls="ShaderPipeline">
          <h4>Shader Pipeline</h4>
        </button>
      </h2>
      <div id="ShaderPipeline" class="accordion-collapse collapse" aria-labelledby="headingThree"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>The engine at first used OpenGL calls to render geometry and it wasn’t until v2.0 shaders were added to the
            pipeline. Being able to draw simple grids with different water effects got us excited about the progress in
            rendering capabilities. Shaders were now part of the resource system and could be dropped and applied to
            mesh components. To take advantage of the new feature, we also added skybox support and outlines for
            selected geometries.</p>
          <img src="Multimedia/Exampletitlevideo.gif" class="img-fluid mx-auto d-block">
          <p>Editing the shaders outside the engine’s scope bothered us enough to decide to improve shader use for v3.0
            and we added a shader editor tool to allow us to modify our shaders in-engine. Changes in shader code are
            parsed searching for defined uniform variables that are able to be set through the material’s resource
            properties for any material referencing the shader. The previous water shaders made are now defined as
            internal resources and there is a button that sets up a gameobject with their own water component with
            customizable uniform fields.</p>
          <p>After playing with shaders, we were comfortable setting up more advanced rendering techniques and
            implementing lights through deferred shading. Instead of iterating light sources per vertex, the renderer
            has 2 passes. First, it outputs framebuffers with pixel data: position, diffuse, and normal. Then, it uses
            these buffers and sends light uniforms for lights to be iterated per pixel. This 2-step pipeline can be
            complemented by adding other rendering procedures like blurs, blooms, ambient occlusion.</p>
          <img src="Multimedia/deferred_light.gif" class="img-fluid mx-auto d-block">
        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingFour">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#ResourceManagement" aria-expanded="false" aria-controls="ResourceManagement">
          <h4>Resource Management</h4>
        </button>
      </h2>
      <div id="ResourceManagement" class="accordion-collapse collapse" aria-labelledby="headingFour"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>The engine’s file system is powered using PhysFS open-sourced cross-platform library. We mount our data.zip
            file to a virtual directory and store all the files used. Inside data.zip we can find the Assets directory
            containing the actual raw files and a Library directory where we store files to a binary format. Library
            files are named by feeding the generated json format string to an MD5 generator that outputs a small unique
            string. This way, different files with the same content are not stored duplicated.</p>
          <img src="Multimedia/file_system_2.PNG" class="img-fluid mx-auto d-block">
          <p>Procedures for loading resources are scoped for errors and reported as logs for the console to show. File
            changes in the directories are scoped using the extra milliseconds between frames. Our intention is to set
            up multi-threading so as to set calls at a parallel thread freeing the main one. Once resources (scenes,
            meshes, materials, skyboxes, etc.) are saved to the Library the renderer gets queued with thumbnails for the
            asset panel. Images files have the image itself for thumbnail in the Assets Panel, but other elements such
            as scenes require setting up a temporal scene and camera to output the asset thumbnail.</p>
        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingFive">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#SceneOptimization" aria-expanded="false" aria-controls="SceneOptimization">
          <h4>Scene Optimization</h4>
        </button>
      </h2>
      <div id="SceneOptimization" class="accordion-collapse collapse" aria-labelledby="headingFive"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>The scene module holds the Entity-Component System. Game objects are organized in a hierarchy and child
            global transforms are calculated based on their local transforms and their parents’ matrix. To improve scene
            performance we built different systems around the scene’s procedures.</p>
          <img src="Multimedia/hierarchy.PNG" class="img-fluid mx-auto d-block">
          <h4>Camera Manager</h4>
          <p>Scenes must have at least one main camera for the renderer to position the point of view. This manager
            flags which cameras must be used to render builds a default one when missing to ensure having a scene
            visual. Cameras store and update their frustum geometry to cull scene elements that are not contained within
            the viewport.</p>
          <h4>Dynamic AABB Tree</h4>
          <p>Camera culling iterated each triangle in the scene to check if the geometry was contained within the
            viewport. To improve this process we added a broad phasing procedure to reduce the amount of geometry
            checked by ordering the scene using a quadtree. This improved performance but we felt it could be improved.
            We thought about upgrading to an octree until we found Erin Catto’s documentation for Blizzard
            Entertainment’s Overwatch approach to scene space partitioning using a dynamic axis-aligned bounding box
            tree. The tree contains boxes paired through their minimum enclosing AABB surface area. Check out his
            detailed explanation <a href="https://box2d.org/files/ErinCatto_DynamicBVH_GDC2019.pdf">here</a>.</p>
          <img src="Multimedia/Dyn_AABB.PNG" class="img-fluid mx-auto d-block">
          <h4>Hash mapped ECS</h4>
          <p>Cameras mentioned previously are positioned inside the scene as Camera Components. Compared to mesh
            components, cameras and transforms must update each frame if they or their parent’s transforms have been
            modified. The first implementation had to travel from game object to game object iterating the hierarchy in
            orden to find components who needed updated values.</p>
          <p>As of v4.0, game objects and components are stored using a hash map. This way data is allocated in a
            contiguous manner for faster iteration. We used to allocate data without order with C++’s new calls and now
            each component type has their own array. This improved the update cycles but meant that pointers were now
            useless, as data is moved around inside the containers. To reference game objects or their components, we
            now use 64-bit unique number identifiers. Through the UIDs, we can map where in the hash the target
            structure is located.</p>
        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingSix">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#UserInterface" aria-expanded="false" aria-controls="UserInterface">
          <h4>User Interface</h4>
        </button>
      </h2>
      <div id="UserInterface" class="accordion-collapse collapse" aria-labelledby="headingSix"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>All GUI elements are powered with the use of <a href="https://github.com/ocornut/imgui">ImGui</a>. This
            open-sourced
            library contains C++ renderer agnostic and self-contained methods for easy editor interface production. The
            editor module handles ImGui setup, holds interface windows and registers user activity. If we were to choose
            the most interesting editor windows, we must mention the shader editor that allows shader code files to be
            edited and reloaded into the pipeline and the particle workspace window where simulations can be edited
            thoroughly. The editor also contains debug drawing calls such as a default grid positioned at origin. Grid,
            game object AABBs and scene space partitioning geometry drawing can be configured in the editor’s settings
            together with the rest of modules.</p>
          <p>On opening the engine, the editor runs ImGui, shows numerous windows and has 2 viewports on display: Game
            Scene from the scene’s main camera and the Editor Scene with the editor’s camera viewpoint. The editor
            counts with its own camera component and controls such as: selecting game object (mouse click), focus camera
            on selection (F), orbiting selection (Alt + Mouse move) and free movement (WASD). When selecting a game
            object, the hierarchy expands and the properties tab show’s selection’s components and game object values.
            Translation, rotation and scaling gizmos will also appear. Transform procedures get queued and can be undone
            (Ctrl+Z) or redone (Ctrl+Y).</p>
            <img src="Multimedia/general_view.png" class="img-fluid mx-auto d-block">
        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingSeven">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#Profiling" aria-expanded="false" aria-controls="Profiling">
          <h4>Profiling</h4>
        </button>
      </h2>
      <div id="Profiling" class="accordion-collapse collapse" aria-labelledby="headingSeven"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>Profiling refers to measuring our systems’ performance. At first we decided to implement
            <a href="https://www.optickprofiler.com/">Brofiler</a> and output function calls to the listener app. It is
            a powerful
            tool full of features, but our interest lies in being able to analyze data visually through the use of
            <a href="https://www.tableau.com/">Tableau</a>. We can feed Tableau procedure data to create graphs from raw
            fields or
            calculated ones to represent the engine’s performance to our liking. Using C++ macros, we set up different
            code configurations for testing environments so as to not pollute code with unnecessary profiling in release
            versions. The macros re-define the already present Brofiler calls and store procedure timings. The next
            table shows a Gantt distribution of RedEye’s startup procedures. Shader setup occupies around 60% of
            Application’s initialization.
          </p>
          <img src="Multimedia/profiling_init.PNG" class="img-fluid mx-auto d-block">
          <p>To test the latest particle system, we expanded RedEye’s internal profiling so as to procure different
            executable files that run subsequent simulations. Once a simulation reaches a duration threshold, it is
            cleared and edited for the next one. The simulations reached up to 400K particles updated in under a
            thirtieth of a second (33ms). Programming data-oriented design paradigms into the particle pipeline improved
            particle cap and results were able to be evaluated comparing test performances.</p>
        </div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingEight">
        <button class="accordion-button collapsed text-white" type="button" data-bs-toggle="collapse"
          data-bs-target="#Website" aria-expanded="false" aria-controls="Website">
          <h4>Website</h4>
        </button>
      </h2>
      <div id="Website" class="accordion-collapse collapse" aria-labelledby="headingEight"
        data-bs-parent="#entrails_content">
        <div class="accordion-body">
          <p>This website forms part of the engine’s development. Not only do we want users to explore our engine, but
            we also aim for supporting them through complementary published resources. The read.me file is displayed at
            the repository’s main page and we had a simple wiki filled out. We only used Github’s repository page to
            showcase the engine, but now we expanded it to include the engine’s own website.</p>
          <p>Because we still wanted everything in RedEye to be open-sourced, we used Github’s domain linking to set it
            up directly from the repository. To build the site’s elements, we used
            <a href="https://getbootstrap.com/">Bootstrap</a>’s front-end open source toolkit. Find out how the code
            ended at the
            <a href="https://github.com/juliamauri/RedEye-Engine/tree/master/docs">docs folder</a>.
          </p>
          <p>Image</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Optional JavaScript -->
  <!-- jQuery first, then Popper.js, then Bootstrap JS -->
  <script src="https://code.jquery.com/jquery-3.4.1.min.js"
    integrity="sha384-vk5WoKIaW/vJyUAd9n/wmopsmNhiy+L2Z+SBxGYnUkunIxVxAv/UtMOhba/xskxh"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"
    integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p"
    crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js"
    integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF"
    crossorigin="anonymous"></script>
  <!-- The core Firebase JS SDK is always required and must be listed first -->
  <script src="https://www.gstatic.com/firebasejs/7.14.1/firebase-app.js"></script>

  <!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
  <script src="https://www.gstatic.com/firebasejs/7.14.1/firebase-analytics.js"></script>


  <script>
    $(function () {

      // check if there is a hash in the url
      if (window.location.hash != '') {
        // remove any accordion panels that are showing (they have a class of 'in')
        $('.collapse').removeClass('in');

        // show the panel based on the hash now:
        $(window.location.hash + '.collapse').collapse('show');
      }

    });
  </script>



  <script crossorigin="anonymous">
    // Your web app's Firebase configuration
    var firebaseConfig = {
      apiKey: "AIzaSyCMOTl92hbee8U9CXHkVDeBxUpGeKDTMWU",
      authDomain: "redeye-4bb97.firebaseapp.com",
      databaseURL: "https://redeye-4bb97.firebaseio.com",
      projectId: "redeye-4bb97",
      storageBucket: "redeye-4bb97.appspot.com",
      messagingSenderId: "85997841293",
      appId: "1:85997841293:web:ce16a597b1baac17fb2bc4",
      measurementId: "G-PE3716BLNW"
    };
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    firebase.analytics();
  </script>

</body>

</html>